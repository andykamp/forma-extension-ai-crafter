import { AnalysisApi } from "./analysis.js";
import { AreaMetricsApi } from "./areaMetrics.js";
import { ElementsApi } from "./elements.js";
import { ExtensionsApi } from "./extensions.js";
import { GeneratorsApi } from "./generators.js";
import { GeometryApi } from "./geometry.js";
import { IframeMessenger, } from "./iframe-messenger.js";
import { IntegrateApi } from "./integrate.js";
import { LibraryApi } from "./library.js";
import { PredictiveAnalysisApi } from "./predictive-analysis.js";
import { ProjectApi } from "./project.js";
import { ProposalApi } from "./proposal.js";
import { QueuedPubSub } from "./queued-pub-sub.js";
import { CameraApi } from "./scene/camera.js";
import { DesignToolApi } from "./scene/design-tool.js";
import { RenderApi } from "./scene/render.js";
import { SunApi } from "./scene/sun.js";
import { TerrainApi } from "./scene/terrain.js";
import { SelectionApi } from "./selection.js";
import { version } from "./version.js";
const defaultAllowedOrigins = [
    // EU Prod
    "https://app.autodeskforma.com",
    /^https:\/\/local\.autodeskforma\.com:/,
    // US Prod
    "https://app.autodeskforma.eu",
    /^https:\/\/local\.autodeskforma\.eu:/,
    // EU Chaos
    "https://app.spacemakerai.eu",
    /^https:\/\/local\.spacemakerai\.eu:/,
];
export class EmbeddedViewSdk {
    config;
    source = window.parent;
    #iframeMessenger;
    origin;
    analysis;
    extensions;
    elements;
    generators;
    geometry;
    integrateElements;
    library;
    project;
    proposal;
    camera;
    sun;
    terrain;
    render;
    selection;
    areaMetrics;
    predictiveAnalysis;
    designTool;
    #customRequestHandlers = new Map();
    #customEventHandlers = new Map();
    #customSubscribeHandlers = new Map();
    #iframeResizer = new ResizeObserver((entries) => {
        const htmlEntry = entries.find((entry) => entry.target === document.documentElement);
        if (htmlEntry) {
            this.#iframeMessenger
                .sendRequest("resizeIframeHeight", {
                height: htmlEntry.contentRect.height,
            })
                .catch((err) => {
                console.log("failed to resize iframe", err);
            });
        }
    });
    #messagePorts = new QueuedPubSub();
    constructor(config) {
        this.config = config;
        this.origin = config?.origin ?? EmbeddedViewSdk.getHostOrigin();
        const allowedOrigins = config?.allowedOrigins ?? defaultAllowedOrigins;
        if (!allowedOrigins.some((allowedOrigin) => typeof allowedOrigin === "string"
            ? allowedOrigin === this.origin
            : allowedOrigin.test(this.origin))) {
            throw new Error(`Unsupported origin: ${this.origin}`);
        }
        this.#iframeMessenger = new IframeMessenger({
            sourceOrigin: this.origin,
            source: this.source,
            requestResolver: (action) => this.#customRequestHandlers.get(action),
            eventResolver: (action) => this.#customEventHandlers.get(action),
            subscribeResolver: (name) => this.#customSubscribeHandlers.get(name),
            debug: config?.debug,
        });
        this.#iframeMessenger.connect();
        void this.#iframeMessenger.sendEvent("sdk-version", {
            version,
        });
        window.addEventListener("beforeunload", () => {
            // Let the host know that we are unloading.
            this.#iframeMessenger.disconnect();
        });
        window.addEventListener("focus", () => {
            // Let the host know that we are focused.
            void this.#iframeMessenger.sendEvent("window-focused");
        });
        this.analysis = new AnalysisApi(this.#iframeMessenger);
        this.extensions = new ExtensionsApi(this.#iframeMessenger);
        this.elements = new ElementsApi(this.#iframeMessenger);
        this.generators = new GeneratorsApi(this.#iframeMessenger);
        this.geometry = new GeometryApi(this.#iframeMessenger);
        this.integrateElements = new IntegrateApi(this.#iframeMessenger);
        this.library = new LibraryApi(this.#iframeMessenger);
        this.project = new ProjectApi(this.#iframeMessenger);
        this.proposal = new ProposalApi(this.#iframeMessenger);
        this.camera = new CameraApi(this.#iframeMessenger);
        this.sun = new SunApi(this.#iframeMessenger);
        this.terrain = new TerrainApi(this.#iframeMessenger);
        this.render = new RenderApi(this.#iframeMessenger);
        this.selection = new SelectionApi(this.#iframeMessenger);
        this.areaMetrics = new AreaMetricsApi(this.#iframeMessenger);
        this.predictiveAnalysis = new PredictiveAnalysisApi(this.#iframeMessenger);
        this.designTool = new DesignToolApi(this.#iframeMessenger);
        this.#iframeResizer.observe(document.documentElement);
        this.#customRequestHandlers.set("receive-message-port", (payload) => {
            this.#messagePorts.publish(payload);
        });
    }
    async ping() {
        return await this.#iframeMessenger.sendRequest("ping");
    }
    /**
     * @hidden
     * @internal
     */
    getIframeMessenger() {
        return this.#iframeMessenger;
    }
    getProjectId() {
        const projectId = new URLSearchParams(window.location.search).get("projectId");
        if (!projectId) {
            throw new Error("Missing query parameter: projectId");
        }
        return projectId;
    }
    getExtensionId() {
        const extensionId = new URLSearchParams(window.location.search).get("extensionId");
        if (!extensionId) {
            throw new Error("Missing query parameter: extensionId");
        }
        return extensionId;
    }
    /**
     * Check for access to perform edit operations in the current project.
     *
     * @example
     * ```js
     * const canEdit = await Forma.getCanEdit()
     * if (canEdit) {
     *  await Forma.proposal.addElement({ urn })
     * } else {
     *   console.log("User need to have collaborator or admin role to add elements")
     * }
     * ```
     */
    async getCanEdit() {
        return await this.#iframeMessenger.sendRequest("access/can-edit");
    }
    /**
     * Retrieve the embedded view ID used to identify this embedded view.
     *
     * You can set a custom embedded view ID when dynamically opening
     * an embedded view inside a floating panel.
     */
    getEmbeddedViewId() {
        const embeddedViewId = new URLSearchParams(window.location.search).get("embeddedViewId");
        if (!embeddedViewId) {
            throw new Error("Missing query parameter: embeddedViewId");
        }
        return embeddedViewId;
    }
    static getHostOrigin() {
        const origin = new URLSearchParams(window.location.search).get("origin");
        if (!origin) {
            throw new Error("Missing query parameter: origin");
        }
        return origin;
    }
    /**
     * @hidden
     * @internal
     */
    setRequestHandler(name, handler) {
        this.#customRequestHandlers.set(name, handler);
    }
    /**
     * @hidden
     * @internal
     */
    setEventHandler(name, handler) {
        this.#customEventHandlers.set(name, handler);
    }
    /**
     * @hidden
     * @internal
     */
    setSubscribeHandler(name, handler) {
        this.#customSubscribeHandlers.set(name, handler);
    }
    /**
     * @hidden
     * @internal
     */
    sendRequest(action, payload, transfer) {
        return this.#iframeMessenger.sendRequest(action, payload, transfer);
    }
    /**
     * @hidden
     * @internal
     */
    sendEvent(action, payload, transfer) {
        return this.#iframeMessenger.sendEvent(action, payload, transfer);
    }
    /**
     * @hidden
     * @internal
     */
    createSubscription(name, handler, options) {
        return this.#iframeMessenger.createSubscription(name, handler, options);
    }
    /**
     * Open another embedded view in a floating panel.
     *
     * The embedded view will be owned by the current embedded view,
     * and automatically closed when the current embedded view is closed.
     *
     * To wait for the embedded view to be ready or being closed, listen to
     * the relevant events via {@link onEmbeddedViewStateChange}
     * before invoking this method. Methods such as {@link createMessagePort}
     * will automatically wait for the embedded view to be ready.
     *
     * If the URL is invalid or the embedded view cannot be initialized,
     * the state of the embedded view will remain open and not connected,
     * until the user closes the panel which triggers the closed state.
     *
     * @experimental
     */
    async openFloatingPanel(options) {
        await this.#iframeMessenger.sendRequest("open-floating-panel", options);
    }
    /**
     * Close an embedded view belonging to this extension.
     *
     * Currently only floating panels can be closed.
     *
     * If the embedded view is not open this will still resolve successfully.
     *
     * @experimental
     */
    async closeEmbeddedView(options) {
        await this.#iframeMessenger.sendRequest("close-embedded-view", options);
    }
    /**
     * Listen to when the state of an embedded view belonging to the current
     * extension changes.
     *
     * @experimental
     */
    async onEmbeddedViewStateChange(handler) {
        return this.#iframeMessenger.createSubscription("on-embedded-view-state-change", handler);
    }
    /**
     * Create a MessagePort that can be used to communicate directly with
     * another embedded view belonging to the current extension.
     *
     * The other embedded view must have called the {@link onMessagePort} method
     * during initialization for this to succeeed.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API
     * @experimental
     */
    async createMessagePort(options) {
        const channel = new MessageChannel();
        await this.#iframeMessenger.sendRequest("create-message-port", {
            embeddedViewId: options.embeddedViewId,
            portName: options.portName,
            port: channel.port2,
        }, [channel.port2]);
        return channel.port1;
    }
    /**
     * Receive a MessagePort initiated from {@link createMessagePort}.
     *
     * The first time this is called, the handler will receive any
     * queued message ports.
     *
     * @returns A function that can be used to unsubscribe.
     *
     * @experimental
     */
    onMessagePort(handler) {
        return this.#messagePorts.subscribe(handler);
    }
}
