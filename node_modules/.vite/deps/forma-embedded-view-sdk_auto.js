import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-LZRLRPEA.js";

// node_modules/forma-embedded-view-sdk/dist/internal/analysis.js
var _iframeMessenger;
var AnalysisApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger, void 0);
    __privateSet(this, _iframeMessenger, iframeMessenger);
  }
  /**
   * Fetch analysis records connected to the currently open proposal.
   *
   * @returns
   * List of relevant analysis records.
   *
   * @example
   * // Fetch all sun analysis records.
   * // Filter to only include those in SUCCEEDED state.
   * const sunAnalyses = await Forma.analysis.list({ analysisTypes: ["sun"] })
   * const succeededSunAnalyses = sunAnalyses.filter(analysis => analysis.status === "SUCCEEDED")
   */
  async list(request) {
    return await __privateGet(this, _iframeMessenger).sendRequest("analysis/list", request);
  }
  /**
   * @beta
   * Trigger a
   * [noise analysis](https://aps.autodesk.com/en/docs/forma/v1/embedded-views/useful-concepts/analysis/noise/)
   * based on the traffic data connected to roads and railways in the proposal. Computes A-weighted decibel levels.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @returns Analysis record for the newly triggered analysis.
   *
   * @example
   * // Trigger noise analysis on selected elements
   * const currentlySelected = await Forma.selection.getSelected()
   * const sunAnalysis = await Forma.analysis.triggerNoise({
   *    selectedElementPaths: currentlySelected
   * })
   * @remarks
   * Noise analysis is a Beta feature of Autodesk Forma.
   *
   */
  async triggerNoise(request) {
    return await __privateGet(this, _iframeMessenger).sendRequest("analysis/trigger-noise", request);
  }
  /**
   * Trigger a
   * [sun analysis](https://aps.autodesk.com/en/docs/forma/v1/embedded-views/useful-concepts/analysis/sun/)
   * for a specific day of the year. Computes sun exposure in hours.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @returns
   * Analysis record for the newly triggered analysis.
   *
   * @example
   * // Trigger sun analysis on selected elements for the summer solstice
   * const currentlySelected = await Forma.selection.getSelected()
   * const sunAnalysis = await Forma.analysis.triggerSun({
   *    selectedElementPaths: currentlySelected,
   *    month: 6,
   *    date: 21
   * })
   */
  async triggerSun(request) {
    return await __privateGet(this, _iframeMessenger).sendRequest("analysis/trigger-sun", request);
  }
  /**
   * Fetch a specific sun analysis.
   *
   * @returns
   * Information about the sun analysis.
   */
  async getSunAnalysis(request) {
    return await __privateGet(this, _iframeMessenger).sendRequest("analysis/get-sun-analysis", request);
  }
  /**
   * Fetch a specific noise analysis.
   *
   * @returns
   * Information about the noise analysis.
   *
   * @remarks
   * Noise analysis is a Beta feature of Autodesk Forma.
   */
  async getNoiseAnalysis(request) {
    return await __privateGet(this, _iframeMessenger).sendRequest("analysis/get-noise-analysis", request);
  }
  /**
   * Fetch
   * [ground grid result](https://aps.autodesk.com/en/docs/forma/v1/embedded-views/useful-concepts/analysis/)
   * for a sun or noise analysis.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @returns
   * Ground grid containing results for the requested analysis.
   *
   * @example
   * // Fetch ground grid for the first listed succeeded sun analysis
   * const sunAnalyses = await Forma.analysis.list({ analysisTypes: ["sun"] })
   * const succeededSunAnalyses = sunAnalyses.filter(analysis => analysis.status === "SUCCEEDED")
   * const groundGrid = await Forma.analysis.getGroundGrid({ analysis: succeededSunAnalyses[0] })
   *
   * @remarks
   * Noise analysis is a Beta feature of Autodesk Forma.
   */
  async getGroundGrid(request) {
    return await __privateGet(this, _iframeMessenger).sendRequest("analysis/get-ground-grid", request);
  }
};
_iframeMessenger = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/areaMetrics.js
var _iframeMessenger2;
var AreaMetricsApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger2, void 0);
    __privateSet(this, _iframeMessenger2, iframeMessenger);
  }
  /**
   * Calculate area metrics for the given paths.
   * If no paths are given, the metrics will be calculated for all elements.
   *
   * @returns
   * Area metrics for the given paths.
   *
   * @example
   * // Calculate area metrics for selected elements
   * const currentlySelected = await Forma.selection.getSelected()
   * const areaMetrics = await Forma.areaMetrics.calculate({
   *   paths: currentlySelected
   * })
   */
  async calculate(request) {
    return await __privateGet(this, _iframeMessenger2).sendRequest("area-metrics/get", request);
  }
};
_iframeMessenger2 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/elements.js
var ElementsApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __publicField(this, "floorStack");
    this.floorStack = new FloorStackApi(iframeMessenger);
  }
};
var _iframeMessenger3;
var FloorStackApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger3, void 0);
    __privateSet(this, _iframeMessenger3, iframeMessenger);
  }
  /**
   * Create a 2.5D building from a stack of floors.
   *
   * By 2.5D, we mean that the building only has vertical walls and flat roofs.
   * The floors are given from bottom to top.
   *
   * Requires edit access to the project. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @returns URN of the created building element.
   */
  async createFromFloors(request) {
    const response = await __privateGet(this, _iframeMessenger3).sendRequest("elements/floor-stack-v2/create-from-floors", request);
    return response;
  }
};
_iframeMessenger3 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/extensions.js
var _iframeMessenger4;
var ExtensionsApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger4, void 0);
    __publicField(this, "storage");
    __privateSet(this, _iframeMessenger4, iframeMessenger);
    this.storage = new ExtensionsStorageApi(iframeMessenger);
  }
  // TODO: Link to more documentation on how to register endpoints for extensions.
  /**
   * Invoke an extension-specific endpoint.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @typeParam T - Type of data returned by endpoint.
   *
   * @returns The data returned by the endpoint.
   *
   */
  async invokeEndpoint(request) {
    return await __privateGet(this, _iframeMessenger4).sendRequest("extensions/invoke-endpoint", request);
  }
};
_iframeMessenger4 = new WeakMap();
var _iframeMessenger5, _textDecoder;
var ExtensionsStorageApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger5, void 0);
    __privateAdd(this, _textDecoder, new TextDecoder());
    __privateSet(this, _iframeMessenger5, iframeMessenger);
  }
  /**
   * Add or replace a storage object.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @example
   * // STORE JSON
   * const myObject = {
   *  someData: "someValue"
   * }
   *
   * await Forma.extensions.storage.setObject({key: "some-key", data: JSON.stringify(myObject)})
   *
   * @example
   * // STORE Float32Array
   *
   * function arrayToBuffer(array: Float32Array): ArrayBuffer {
   *   const buffer = new ArrayBuffer(array.length * Float32Array.BYTES_PER_ELEMENT);
   *   const arr = new Float32Array(buffer);
   *   arr.set(array);
   *   return arr;
   * }
   *
   * const arr = new Float32Array(100).fill(Math.random())
   * await Forma.extensions.storage.setObject({key: "someKey", data: arrayToBuffer(arr)})
   *
   */
  async setObject(request) {
    const url = await __privateGet(this, _iframeMessenger5).sendRequest("extension-installation-storage/set", {
      key: request.key,
      metadata: request.metadata
    });
    const awsRes = await fetch(url, {
      method: "PUT",
      body: request.data
    });
    if (!awsRes.ok) {
      throw new Error(`Failed to put data to S3: ${awsRes.status}: ${awsRes.statusText}`);
    }
  }
  /**
   * Utility function to fetch string objects without needing to decode an array buffer.
   *
   * @returns The data parsed as UTF-8, including metadata if present.
   *
   * @example
   * // READING JSON
   * const res = await Forma.extensions.storage.getTextObject({
   *   key: "some-key",
   * })
   * if (!res) {
   *    return
   * }
   * const metadata = JSON.parse(data.metadata ?? "{}")
   * const data = res.data
   *
   * @example
   * function loadImageFromEncodedPng(
   *   url: string,
   * ): Promise<HtmlImageElement> {
   *   return new Promise((resolve, reject) => {
   *     const img = new Image()
   *     img.onload = () => {
   *       resolve(img)
   *     }
   *     img.onerror = () => {
   *       reject(new Error("Failed to load image"))
   *     }
   *     img.src = url
   *   })
   * }
   *
   * async function createCanvasFromDataUrl(
   *   url: string,
   * ): Promise<HtmlCanvasElement | void> {
   *  const canvas = document.createElement("canvas")
   *  const ctx = canvas.getContext("2d")
   *  const img = await loadImage(url)
   *  canvas.height = img.height
   *  canvas.width = img.width
   *  ctx.drawImage(ctx, img, 0, 0)
   *  return canvas
   * }
   *
   * const res = await Forma.extensions.storage.getTextObject({
   *   key: "some-png-key",
   * })
   * if (!res) {
   *    return
   * }
   * const canvas = createCanvasFromDataUrl(res.data)
   *
   */
  async getTextObject(request) {
    const res = await __privateGet(this, _iframeMessenger5).sendRequest("extension-installation-storage/get", request);
    if (!res) {
      return;
    }
    return {
      ...res,
      data: __privateGet(this, _textDecoder).decode(res.data)
    };
  }
  /**
   * Fetch the data for the specified key.
   *
   * Use this function when you're **not** fetching text data, such as geometry
   * or analysis results.
   *
   * @returns The data as an ArrayBuffer, including metadata if present.
   *
   * @example
   * const res = await Forma.extensions.storage.getBinaryObject({
   *   key: "my-float32-array",
   * })
   * if (!res) {
   *  return
   * }
   * const terrainSlope: Float32Array = new Float32Array(res.data)
   * const metadata = JSON.parse(res.metadata ?? "{}")
   *
   */
  async getBinaryObject(request) {
    return await __privateGet(this, _iframeMessenger5).sendRequest("extension-installation-storage/get", request);
  }
  /**
   * List all storage objects for the extension in the current authcontext.
   *
   * @returns List of filtered objects with relevant information.
   *
   * @example
   * const availableObjects = await Forma.extensions.storage.listObjects().results
   */
  async listObjects(request) {
    return await __privateGet(this, _iframeMessenger5).sendRequest("extension-installation-storage/list", request);
  }
  /**
   * Delete object corresponding to the specified key.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @example
   * // Store a JSON object and delete it afterwards
   * const myObject = {
   *  someData: "someValue"
   * }
   * await Forma.extensions.storage.setObject({key: "some-key", data: JSON.stringify(myObject)})
   * await Forma.extensions.storage.deleteObject({key: "some-key"}})
   */
  async deleteObject(request) {
    await __privateGet(this, _iframeMessenger5).sendRequest("extension-installation-storage/delete", request);
  }
};
_iframeMessenger5 = new WeakMap();
_textDecoder = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/generators.js
var _iframeMessenger6;
var GeneratorsApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger6, void 0);
    __privateSet(this, _iframeMessenger6, iframeMessenger);
  }
  /**
   * Create or replace a generator.
   *
   * @returns The created or replaced generator resource model.
   */
  async put(request) {
    return await __privateGet(this, _iframeMessenger6).sendRequest("generators/put", request);
  }
  /**
   * List out generators within the specified authcontext.
   *
   * @returns List of registered generators.
   */
  async list(request) {
    return await __privateGet(this, _iframeMessenger6).sendRequest("generators/list", {
      authcontext: request == null ? void 0 : request.authcontext
    });
  }
};
_iframeMessenger6 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/geometry.js
var _iframeMessenger7;
var GeometryApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger7, void 0);
    __privateSet(this, _iframeMessenger7, iframeMessenger);
  }
  /**
   * Fetch paths of all elements in a proposal tagged with a specific category.
   * Traverses the element tree to also find any nested children tagged as well.
   *
   * @returns
   * List of paths to elements tagged with the given category.
   *
   * @example
   * // Fetch all paths to buildings in the current proposal.
   * const buildingPaths = await Forma.geometry.getPathsByCategory({ category: "buildings" })
   */
  async getPathsByCategory(request) {
    return await __privateGet(this, _iframeMessenger7).sendRequest("geometry/get-paths-by-category", request);
  }
  /**
   * Fetch the paths of all elements in a proposal with the property 'virtual' set to true.
   * Traverses the element tree to also find any nested children tagged as well.
   *
   * The virtual property can be used to describe something that isn't real,
   * like a constraint or an illustrative boy with balloon. If this is set,
   * analyses and possibly other modes will ignore the element.
   *
   * @returns
   * List of paths to elements tagged as virtual.
   *
   * @example
   * // Fetch paths to all elements in the current proposal that are virtual.
   * const virtualElementPaths = await Forma.geometry.getPathsForVirtualElements()
   */
  async getPathsForVirtualElements(request) {
    return await __privateGet(this, _iframeMessenger7).sendRequest("geometry/get-paths-for-virtual-elements", { urn: request == null ? void 0 : request.urn });
  }
  /**
   * Fetch footprint representation of an element. Does not traverse children of
   * the element, so if any of them have footprint representations which
   * are of interest they need to be fetched separately using their complete path.
   *
   * @returns
   * Footprint representation of the element pointed to by the given path.
   *
   * @example
   * // Fetch footprint of the first found proposal site limit.
   * const siteLimitPaths = await Forma.geometry.getPathsByCategory({ category: "site_limit" })
   * const siteLimitFootprint = await Forma.geometry.getFootprint({ path: siteLimitPaths[0] })
   */
  async getFootprint(request) {
    return await __privateGet(this, _iframeMessenger7).sendRequest("geometry/get-footprint", request);
  }
  /**
   * Fetch mesh representation of an element and its children. Traverses the
   * element tree to also find any nested children with the `volumeMesh` representation.
   * All found meshes are concatenated into a flat list of triangles.
   *
   * @returns
   * Mesh representation (list of triangles with vertex coordinates represented
   * as `Float32`s) of the element pointed to by the given path and its children.
   *
   * @example
   * // Fetch mesh representation for the entire proposal and count the number of triangles.
   * const mesh = await Forma.geometry.getTriangles()
   * const numberOfTriangles = mesh.length / 3
   *
   * @example
   * // Fetch mesh representation for one of the elements with category building and its children.
   * const buildingPaths = await Forma.geometry.getPathsByCategory({category: "building"})
   * if (buildingPaths.length > 0 ) {
   *    const mesh = await Forma.geometry.getTriangles({path: buildingPaths[0]})
   * }
   *
   * @example
   * // Fetch mesh representation for the entire proposal except elements with category vegetation and their children.
   * const vegetationPaths = await Forma.geometry.getPathsByCategory({category: "vegetation"})
   * const mesh = await Forma.geometry.getTriangles({excludedPaths: vegetationPaths})
   */
  async getTriangles(request) {
    return await __privateGet(this, _iframeMessenger7).sendRequest("geometry/get-triangles", {
      path: request == null ? void 0 : request.path,
      urn: request == null ? void 0 : request.urn,
      excludedPaths: request == null ? void 0 : request.excludedPaths
    });
  }
};
_iframeMessenger7 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/iframe-messenger.js
var RequestError = class extends Error {
  constructor(message, type, data, options) {
    super(message, {
      cause: options == null ? void 0 : options.cause
    });
    __publicField(this, "type");
    __publicField(this, "data");
    this.type = type;
    this.data = data;
  }
};
function parseErrorPayload(payload) {
  if (payload instanceof Error) {
    return payload;
  }
  if (payload != null && typeof payload === "object" && "message" in payload && typeof payload.message === "string" && "type" in payload && typeof payload.type === "string" && "data" in payload) {
    return new RequestError(payload.message, payload.type, payload.data);
  }
  console.error("Unknown error", payload);
  throw new Error("Unknown error occurred. See console");
}
function toErrorPayload(error) {
  if (error instanceof RequestError) {
    return {
      message: error.message,
      type: error.type,
      data: error.data
    };
  }
  return error;
}
var messageTypeRequest = "IFRAME-MESSAGE-REQUEST";
var messageTypeResponse = "IFRAME-MESSAGE-RESPONSE";
var messageTypeEvent = "IFRAME-MESSAGE-EVENT";
var connectEventAction = "_connect";
var disconnectEventAction = "_disconnect";
var createSubscriptionRequestAction = "_createSubscription";
var removeSubscriptionRequestAction = "_removeSubscription";
var subscriptionEventAction = "_subscriptionEvent";
function isRequest(data) {
  return typeof data === "object" && data != null && "id" in data && "action" in data && "type" in data && data.type === messageTypeRequest;
}
function isResponse(data) {
  return typeof data === "object" && data != null && "id" in data && "type" in data && data.type == messageTypeResponse;
}
function isEvent(data) {
  return typeof data === "object" && data != null && "action" in data && "type" in data && data.type === messageTypeEvent;
}
var State;
(function(State2) {
  State2["INITIALIZED"] = "initialized";
  State2["CONNECTING"] = "connecting";
  State2["ESTABLISHED"] = "established";
  State2["DISCONNECTED"] = "disconnected";
})(State || (State = {}));
var _delegate;
var PubSub = class {
  constructor() {
    __privateAdd(this, _delegate, new EventTarget());
  }
  subscribe(type, handler) {
    const internalHandler = (_event) => {
      const event = _event;
      handler(event.detail);
    };
    __privateGet(this, _delegate).addEventListener(type, internalHandler);
    return () => {
      __privateGet(this, _delegate).removeEventListener(type, internalHandler);
    };
  }
  publish(type, data) {
    __privateGet(this, _delegate).dispatchEvent(new CustomEvent(type, {
      detail: data
    }));
  }
};
_delegate = new WeakMap();
var _state, _subscriptionEventHandlers, _unsubscribeHandlers, _internalEvents, _setState, setState_fn, _processIncomingMessage, _processOutgoingMessage, _messageHandler, _handleConnectAction, handleConnectAction_fn, _handleDisconnectAction, handleDisconnectAction_fn, _handleEvent, handleEvent_fn, _getRequestHandler, getRequestHandler_fn, _handleRequest, handleRequest_fn, _receive, receive_fn, _sendRequestInternal, sendRequestInternal_fn, _sendEventInternal, sendEventInternal_fn, _postMessage, postMessage_fn, _getTargetOrigin, getTargetOrigin_fn, _removeSubscription, removeSubscription_fn, _unsubscribeAllHandlers, unsubscribeAllHandlers_fn, _handleCreateSubscriptionRequest, handleCreateSubscriptionRequest_fn, _handleRemoveSubscriptionRequest, handleRemoveSubscriptionRequest_fn, _handleSubscriptionEvent, handleSubscriptionEvent_fn;
var IframeMessenger = class {
  constructor(options) {
    __privateAdd(this, _setState);
    __privateAdd(this, _handleConnectAction);
    __privateAdd(this, _handleDisconnectAction);
    __privateAdd(this, _handleEvent);
    __privateAdd(this, _getRequestHandler);
    __privateAdd(this, _handleRequest);
    __privateAdd(this, _receive);
    __privateAdd(this, _sendRequestInternal);
    __privateAdd(this, _sendEventInternal);
    __privateAdd(this, _postMessage);
    __privateAdd(this, _getTargetOrigin);
    __privateAdd(this, _removeSubscription);
    __privateAdd(this, _unsubscribeAllHandlers);
    __privateAdd(this, _handleCreateSubscriptionRequest);
    __privateAdd(this, _handleRemoveSubscriptionRequest);
    __privateAdd(this, _handleSubscriptionEvent);
    __privateAdd(this, _state, State.INITIALIZED);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __privateAdd(this, _subscriptionEventHandlers, /* @__PURE__ */ new Map());
    __privateAdd(this, _unsubscribeHandlers, /* @__PURE__ */ new Map());
    __publicField(this, "debug");
    __privateAdd(this, _internalEvents, new PubSub());
    __publicField(this, "source");
    __publicField(this, "sourceOrigin");
    __publicField(this, "incomingMessageInterceptorResolver");
    __publicField(this, "outgoingMessageInterceptorResolver");
    __publicField(this, "requestResolver");
    __publicField(this, "eventResolver");
    __publicField(this, "subscribeResolver");
    __privateAdd(this, _processIncomingMessage, (message) => {
      var _a;
      const interceptor = (_a = this.incomingMessageInterceptorResolver) == null ? void 0 : _a.call(this);
      if (!interceptor) {
        return message;
      }
      const result = interceptor(message);
      if (this.debug) {
        console.log("Resulting data after message interceptor", result);
      }
      return result;
    });
    __privateAdd(this, _processOutgoingMessage, (message, transfer, request) => {
      var _a;
      const interceptor = (_a = this.outgoingMessageInterceptorResolver) == null ? void 0 : _a.call(this);
      if (!interceptor) {
        return message;
      }
      const messageCopy = structuredClone(message, {
        transfer: transfer ?? []
      });
      const result = interceptor(messageCopy, {
        request
      });
      if (this.debug) {
        console.log("Resulting data after message interceptor", result);
      }
      return result;
    });
    __privateAdd(this, _messageHandler, (message) => {
      const source = message.source;
      if (source == null || source !== this.source || this.sourceOrigin != null && message.origin !== this.sourceOrigin) {
        return;
      }
      if (this.debug) {
        console.log(`Message from origin ${message.origin}:`, message.data);
      }
      const data = __privateGet(this, _processIncomingMessage).call(this, message.data);
      if (isEvent(data)) {
        __privateMethod(this, _handleEvent, handleEvent_fn).call(this, data);
      }
      if (isRequest(data)) {
        __privateMethod(this, _handleRequest, handleRequest_fn).call(this, data, message, source);
      }
    });
    this.source = options.source;
    this.sourceOrigin = options.sourceOrigin;
    this.requestResolver = options.requestResolver;
    this.eventResolver = options.eventResolver;
    this.subscribeResolver = options.subscribeResolver;
    this.debug = options.debug ?? false;
    this.incomingMessageInterceptorResolver = options.incomingMessageInterceptorResolver;
    this.outgoingMessageInterceptorResolver = options.outgoingMessageInterceptorResolver;
    __privateGet(this, _internalEvents).subscribe("state", ({ state }) => {
      if (state === State.DISCONNECTED) {
        __privateMethod(this, _unsubscribeAllHandlers, unsubscribeAllHandlers_fn).call(this);
      }
    });
    window.addEventListener("message", __privateGet(this, _messageHandler));
  }
  connect() {
    if (__privateGet(this, _state) === State.INITIALIZED || __privateGet(this, _state) === State.DISCONNECTED) {
      __privateMethod(this, _sendEventInternal, sendEventInternal_fn).call(this, connectEventAction, null, false).catch((e) => {
        console.error("Sending connect action failed", e);
      });
      __privateMethod(this, _setState, setState_fn).call(this, State.CONNECTING);
    }
  }
  disconnect() {
    __privateMethod(this, _sendEventInternal, sendEventInternal_fn).call(this, disconnectEventAction, null, false).catch((e) => {
      console.error("Sending disconnect action failed", e);
    });
    __privateMethod(this, _setState, setState_fn).call(this, State.DISCONNECTED);
  }
  /**
   * Subscribe to state transitions for being connected and
   * from being connected to disconnected.
   *
   * This essentially acts as a boolean flag if it is connected
   * or not.
   */
  onStateChange(handler) {
    return __privateGet(this, _internalEvents).subscribe("state", ({ state, prevState }) => {
      if (state === State.ESTABLISHED && prevState !== State.ESTABLISHED) {
        handler("connected");
      } else if (state !== State.ESTABLISHED && prevState === State.ESTABLISHED) {
        handler("disconnected");
      }
    });
  }
  get isConnected() {
    return __privateGet(this, _state) === State.ESTABLISHED;
  }
  /**
   * Wait for the state to be connected.
   *
   * If a disconnect (e.g. due to unmount) is requested before being
   * connected, the promise will be rejected to ensure the promise
   * is fulfilled.
   */
  connectedPromise() {
    if (this.isConnected) {
      return Promise.resolve();
    }
    if (this.debug) {
      console.log("connectedPromise waiting for connection...");
    }
    return new Promise((resolve, reject) => {
      const unsubscribe = __privateGet(this, _internalEvents).subscribe("state", ({ state }) => {
        switch (state) {
          case State.DISCONNECTED:
            unsubscribe();
            reject(new Error("Disconnected"));
            break;
          case State.ESTABLISHED:
            unsubscribe();
            resolve();
            break;
        }
      });
    });
  }
  async sendRequest(action, payload, transfer) {
    return __privateMethod(this, _sendRequestInternal, sendRequestInternal_fn).call(this, action, payload, true, transfer);
  }
  async sendEvent(action, payload, transfer) {
    await __privateMethod(this, _sendEventInternal, sendEventInternal_fn).call(this, action, payload, true, transfer);
  }
  async createSubscription(name, handler, options) {
    const subscriptionId = crypto.randomUUID();
    __privateGet(this, _subscriptionEventHandlers).set(subscriptionId, handler);
    if (this.debug) {
      console.log(`Creating subscription with ID ${subscriptionId} for ${name}`);
    }
    try {
      const payload = {
        subscriptionId,
        name
      };
      if (options) {
        payload.options = options;
      }
      await __privateMethod(this, _sendRequestInternal, sendRequestInternal_fn).call(this, createSubscriptionRequestAction, payload, true);
    } catch (e) {
      throw new Error("Failed to create subscription", { cause: e });
    }
    return {
      unsubscribe: () => {
        if (this.debug) {
          console.log(`Unsubscribing from subscription ${subscriptionId} for ${name}`);
        }
        __privateGet(this, _subscriptionEventHandlers).delete(subscriptionId);
        __privateMethod(this, _removeSubscription, removeSubscription_fn).call(this, subscriptionId);
      }
    };
  }
};
_state = new WeakMap();
_subscriptionEventHandlers = new WeakMap();
_unsubscribeHandlers = new WeakMap();
_internalEvents = new WeakMap();
_setState = new WeakSet();
setState_fn = function(state) {
  const prevState = __privateGet(this, _state);
  __privateSet(this, _state, state);
  __privateGet(this, _internalEvents).publish("state", {
    state,
    prevState
  });
};
_processIncomingMessage = new WeakMap();
_processOutgoingMessage = new WeakMap();
_messageHandler = new WeakMap();
_handleConnectAction = new WeakSet();
handleConnectAction_fn = function(payload) {
  if (__privateGet(this, _state) !== State.INITIALIZED && __privateGet(this, _state) !== State.CONNECTING) {
    return;
  }
  if (!(payload == null ? void 0 : payload.ack)) {
    const response = {
      ack: true
    };
    __privateMethod(this, _sendEventInternal, sendEventInternal_fn).call(this, connectEventAction, response, false).catch((e) => {
      console.error("Sending event failed", e);
    });
  }
  __privateMethod(this, _setState, setState_fn).call(this, State.ESTABLISHED);
};
_handleDisconnectAction = new WeakSet();
handleDisconnectAction_fn = function(payload) {
  if (__privateGet(this, _state) === State.DISCONNECTED) {
    return;
  }
  if (!(payload == null ? void 0 : payload.ack)) {
    const response = {
      ack: true
    };
    __privateMethod(this, _sendEventInternal, sendEventInternal_fn).call(this, disconnectEventAction, response, false).catch((e) => {
      console.error("Sending event failed", e);
    });
  }
  __privateMethod(this, _setState, setState_fn).call(this, State.DISCONNECTED);
};
_handleEvent = new WeakSet();
handleEvent_fn = function(message) {
  if (message.action === connectEventAction) {
    __privateMethod(this, _handleConnectAction, handleConnectAction_fn).call(this, message.payload);
    return;
  }
  if (message.action === disconnectEventAction) {
    __privateMethod(this, _handleDisconnectAction, handleDisconnectAction_fn).call(this, message.payload);
    return;
  }
  if (message.action === subscriptionEventAction) {
    __privateMethod(this, _handleSubscriptionEvent, handleSubscriptionEvent_fn).call(this, message.payload);
    return;
  }
  if (this.eventResolver) {
    const handler = this.eventResolver(message.action);
    if (handler == null) {
      console.warn("Unknown action for message", message);
      return;
    }
    handler(message.payload);
  }
};
_getRequestHandler = new WeakSet();
getRequestHandler_fn = function(action) {
  var _a;
  switch (action) {
    case createSubscriptionRequestAction:
      return __privateMethod(this, _handleCreateSubscriptionRequest, handleCreateSubscriptionRequest_fn).bind(this);
    case removeSubscriptionRequestAction:
      return __privateMethod(this, _handleRemoveSubscriptionRequest, handleRemoveSubscriptionRequest_fn).bind(this);
    default:
      return (_a = this.requestResolver) == null ? void 0 : _a.call(this, action);
  }
};
_handleRequest = new WeakSet();
handleRequest_fn = function(request, event, source) {
  const reply = (payload, error) => {
    const response = {
      id: request.id,
      type: messageTypeResponse,
      payload,
      error
    };
    const targetOrigin = __privateMethod(this, _getTargetOrigin, getTargetOrigin_fn).call(this, event.origin);
    if (this.debug) {
      console.log(`Sending message to ${targetOrigin}:`, response);
    }
    source.postMessage(__privateGet(this, _processOutgoingMessage).call(this, response, void 0, request), targetOrigin);
  };
  const handler = __privateMethod(this, _getRequestHandler, getRequestHandler_fn).call(this, request.action);
  if (handler == null) {
    console.warn("Unknown action for request", request);
    reply(new Error(`Unknown action: ${request.action}`), true);
    return;
  }
  Promise.resolve().then(() => handler(request.payload)).then((response) => {
    reply(response);
  }).catch((err) => {
    console.error(`Failed during request action ${request.action}`, err);
    reply(toErrorPayload(err), true);
  });
};
_receive = new WeakSet();
receive_fn = function(id) {
  let callback;
  return new Promise((resolve, reject) => {
    callback = (event) => {
      if (event.source === this.source && (this.sourceOrigin == null || event.origin === this.sourceOrigin) && isResponse(event.data) && event.data.id === id) {
        if (event.data.error) {
          reject(parseErrorPayload(event.data.payload));
        } else {
          resolve(event.data.payload);
        }
      }
    };
    window.addEventListener("message", callback);
  }).finally(() => {
    window.removeEventListener("message", callback);
  });
};
_sendRequestInternal = new WeakSet();
sendRequestInternal_fn = async function(action, payload, waitForConnected, transfer) {
  const id = crypto.randomUUID();
  const responsePromise = __privateMethod(this, _receive, receive_fn).call(this, id);
  const message = {
    id,
    type: messageTypeRequest,
    action,
    payload
  };
  const [response] = await Promise.all([
    responsePromise,
    __privateMethod(this, _postMessage, postMessage_fn).call(this, message, transfer, waitForConnected)
  ]);
  return response;
};
_sendEventInternal = new WeakSet();
sendEventInternal_fn = async function(action, payload, waitForConnected, transfer) {
  const message = {
    type: messageTypeEvent,
    action,
    payload
  };
  await __privateMethod(this, _postMessage, postMessage_fn).call(this, message, transfer, waitForConnected);
};
_postMessage = new WeakSet();
postMessage_fn = async function(message, transfer, waitForConnected) {
  if (this.source == null) {
    throw new Error("Missing source");
  }
  const targetOrigin = __privateMethod(this, _getTargetOrigin, getTargetOrigin_fn).call(this, this.sourceOrigin);
  if (this.debug) {
    console.log(`Sending message to ${targetOrigin}:`, message);
  }
  if (waitForConnected) {
    await this.connectedPromise();
  }
  this.source.postMessage(__privateGet(this, _processOutgoingMessage).call(this, message, transfer), targetOrigin, transfer);
};
_getTargetOrigin = new WeakSet();
getTargetOrigin_fn = function(value) {
  return value === "null" || value == null ? "*" : value;
};
_removeSubscription = new WeakSet();
removeSubscription_fn = function(subscriptionId) {
  const payload = {
    subscriptionId
  };
  __privateMethod(this, _sendRequestInternal, sendRequestInternal_fn).call(this, removeSubscriptionRequestAction, payload, true).catch((e) => {
    console.warn("Failed to remove subscription", e);
  });
};
_unsubscribeAllHandlers = new WeakSet();
unsubscribeAllHandlers_fn = function() {
  for (const unsubscribe of __privateGet(this, _unsubscribeHandlers).values()) {
    try {
      unsubscribe();
    } catch (e) {
      console.warn("Failed to unsubscribe", e);
    }
  }
  __privateGet(this, _unsubscribeHandlers).clear();
  __privateGet(this, _subscriptionEventHandlers).clear();
};
_handleCreateSubscriptionRequest = new WeakSet();
handleCreateSubscriptionRequest_fn = async function(payload) {
  var _a;
  const subscribe = (_a = this.subscribeResolver) == null ? void 0 : _a.call(this, payload.name);
  if (!subscribe) {
    throw new Error(`Unknown subscription name: ${payload.name}`);
  }
  const sendEvent = (data) => {
    const event = {
      subscriptionId: payload.subscriptionId,
      data
    };
    __privateMethod(this, _sendEventInternal, sendEventInternal_fn).call(this, subscriptionEventAction, event, true).catch((err) => {
      console.error("Sending event failed", err);
    });
  };
  const { unsubscribe } = await subscribe(sendEvent, payload.options);
  __privateGet(this, _unsubscribeHandlers).set(payload.subscriptionId, unsubscribe);
  return {
    ack: true
  };
};
_handleRemoveSubscriptionRequest = new WeakSet();
handleRemoveSubscriptionRequest_fn = function(payload) {
  const unsubscribe = __privateGet(this, _unsubscribeHandlers).get(payload.subscriptionId);
  if (unsubscribe) {
    unsubscribe();
    __privateGet(this, _unsubscribeHandlers).delete(payload.subscriptionId);
  }
  return {
    ack: true
  };
};
_handleSubscriptionEvent = new WeakSet();
handleSubscriptionEvent_fn = function(event) {
  const subscriptionId = event.subscriptionId;
  const handler = __privateGet(this, _subscriptionEventHandlers).get(subscriptionId);
  if (handler == null) {
    console.debug(`Unknown subscription ID: ${event.subscriptionId}`, event);
    return;
  }
  handler(event.data);
};

// node_modules/forma-embedded-view-sdk/dist/internal/integrate.js
var _iframeMessenger8;
var IntegrateApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger8, void 0);
    __privateSet(this, _iframeMessenger8, iframeMessenger);
  }
  /**
   * Create a hierarchy of elements in the integrate element system.
   *
   * More information about the integrate element system can be seen
   * at https://aps.autodesk.com/en/docs/forma/v1/http-specification/integrate-api/
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @returns ID, URN, and revision of the root element created.
   *
   * @example
   * const upload = await Forma.integrateElements.uploadFile({
   *   data: "glb data here...",
   * })
   *
   * const { urn } = await Forma.integrateElements.createElementHierarchy({
   *   data: {
   *     rootElement: "root",
   *     elements: {
   *       root: {
   *         id: "root",
   *         properties: {
   *           geometry: {
   *             type: "File",
   *             format: "glb",
   *             s3Id: upload.fileId,
   *           },
   *         },
   *       },
   *     },
   *   },
   * })
   *
   * console.log(`Created element: ${urn}`)
   */
  async createElementHierarchy(request) {
    return await __privateGet(this, _iframeMessenger8).sendRequest("integrate/create-element-hierarchy", request);
  }
  /**
   * Upload a file to the integrate file storage. Files stored here are can only
   * be retrieved in relation to an element. An example of this is uploading a
   * geometric file - e.g. GLB or GeoJSON files.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @returns Unique identifier for the uploaded file.
   */
  async uploadFile(request) {
    return await __privateGet(this, _iframeMessenger8).sendRequest("integrate/upload-file", request);
  }
};
_iframeMessenger8 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/library.js
var _iframeMessenger9;
var LibraryApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger9, void 0);
    __privateSet(this, _iframeMessenger9, iframeMessenger);
  }
  /**
   * Add data to Library as a new item.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @returns The newly created item.
   *
   * @example
   * const urn = mockRegisterElementInSystem() // See e.g. integrate-elements module
   * const item = await Forma.library.createItem({
   *  data: { name: "My new item", status: "success", urn: urn }
   * })
   */
  async createItem(request) {
    return await __privateGet(this, _iframeMessenger9).sendRequest("library/create-item", request);
  }
  /**
   * Update an existing library item.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @returns The updated item.
   */
  async updateItem(request) {
    return await __privateGet(this, _iframeMessenger9).sendRequest("library/update-item", request);
  }
  /**
   * Delete an existing library item.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   */
  async deleteItem(request) {
    await __privateGet(this, _iframeMessenger9).sendRequest("library/delete-item", request);
  }
};
_iframeMessenger9 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/predictive-analysis.js
var _iframeMessenger10;
var PredictiveAnalysisApi = class {
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger10, void 0);
    __privateSet(this, _iframeMessenger10, iframeMessenger);
  }
  /**
   * This function return the wind parameters used by Forma to predict wind conditions.
   * It includes a wind rose with 8 directions and a surface roughness.
   */
  async getWindParameters() {
    return await __privateGet(this, _iframeMessenger10).sendRequest("prediction/get-wind-parameters");
  }
  /**
   * Predict wind conditions usings Forma's rapid wind model.
   * Read more about rapid wind at [Forma Help](https://help.autodeskforma.com/en/articles/6977396-rapid-wind-analysis).
   *
   * @returns 2d grid of wind conditions. For wind comfort values are 0-4 where lower is better conditions.
   *
   * @example
   * const windRose = await Forma.prediction.getWindParameters()
   * // See HeightMaps for more infor on how to create heightMaps
   * const heightMaps = computeHeightMaps(terrainGeometry, terrainAndBuildingsGeometry)
   * const prediction = await Forma.prediction.predictWind({
   *  heightMaps,
   *  windRose,
   *  type: "comfort",
   *  roughness: windRose.roughness,
   *  comfortScale: "lawson_lddc",
   * })
   * // calculate statistics, mix with other grids, etc.
   */
  async predictWind(request) {
    return await __privateGet(this, _iframeMessenger10).sendRequest("prediction/predict-wind", request);
  }
};
_iframeMessenger10 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/project.js
var _iframeMessenger11;
var ProjectApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger11, void 0);
    __privateSet(this, _iframeMessenger11, iframeMessenger);
  }
  /**
   * Fetch all project metadata.
   *
   * @returns The project metadata.
   *
   * @example
   * const projectMetadata = await Forma.project.get()
   */
  async get() {
    return await __privateGet(this, _iframeMessenger11).sendRequest("project/get");
  }
  /**
   * Fetch project country code.
   *
   * @hidden
   * @deprecated Use countryCode from {@link get} instead.
   *
   * @returns Country code for the project.
   *
   * @example
   * const countryCode = await Forma.project.getCountryCode()
   */
  async getCountryCode() {
    return await __privateGet(this, _iframeMessenger11).sendRequest("project/get-country-code");
  }
  /**
   * Fetch project location (latitude and longitude).
   *
   * @returns Geolocation for the project as [latitude, longitude].
   *
   * @example
   * const [latitude, longitude] = await Forma.project.getGeoLocation()
   */
  async getGeoLocation() {
    return await __privateGet(this, _iframeMessenger11).sendRequest("project/get-geo-location");
  }
  /**
   * Fetch project timezone.
   *
   * @hidden
   * @deprecated Use timezone from {@link get} instead.
   *
   * @returns Timezone for the project.
   *
   * @example
   * const timezone = await Forma.project.getTimezone()
   */
  async getTimezone() {
    return await __privateGet(this, _iframeMessenger11).sendRequest("project/get-timezone");
  }
};
_iframeMessenger11 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/proposal.js
var _iframeMessenger12;
var ProposalApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger12, void 0);
    __privateSet(this, _iframeMessenger12, iframeMessenger);
  }
  /**
   * Fetch the top level URN for the proposal.
   *
   * @returns Root URN
   *
   * @example
   * const rootUrn = await Forma.proposal.getRootUrn()
   */
  async getRootUrn() {
    return await __privateGet(this, _iframeMessenger12).sendRequest("proposal/get-root-urn");
  }
  /**
   * Fetch the unique identifier of the proposal.
   *
   * @returns Proposal ID
   *
   * @example
   * const proposalId = await Forma.proposal.getId()
   */
  async getId() {
    return await __privateGet(this, _iframeMessenger12).sendRequest("proposal/get-id");
  }
  /**
   * Add a new element to the proposal element tree.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @returns { path: string } object with the path of the new element
   *
   * @example
   * const urn = mockRegisterElementInSystem() // See e.g. integrate-elements module
   * const { path } = await Forma.proposal.addElement({ urn })
   */
  async addElement(request) {
    return await __privateGet(this, _iframeMessenger12).sendRequest("proposal/add-element", request);
  }
  /**
   * Replace an element in the proposal.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @example
   * const urn = mockRegisterElementInSystem() // See e.g. integrate-elements module
   * const { path } = await Forma.proposal.addElement({ urn })
   * const newUrn = mockRegisterElementInSystem() // See e.g. integrate-elements module
   * await Forma.proposal.replaceElement({ path, newUrn })
   */
  async replaceElement(request) {
    await __privateGet(this, _iframeMessenger12).sendRequest("proposal/replace-element", request);
  }
  /**
   * Replace existing terrain on the proposal.
   *
   * Requires edit access. See {@link EmbeddedViewSdk.getCanEdit | getCanEdit} for more info.
   *
   * @example
   * const glb = createGlbSomehow()
   * await Forma.proposal.replaceTerrain(glb)
   */
  async replaceTerrain(request) {
    await __privateGet(this, _iframeMessenger12).sendRequest("proposal/terrain/replace", request);
  }
  /**
   * Subscribe to changes in the proposal.
   *
   * @example
   * const { unsubscribe } = await Forma.proposal.subscribe(({ rootUrn }) => {
   *  console.log("updated urn is", rootUrn)
   * });
   *
   * @param callback event handler for each proposal change
   * @returns { unsubscribe: () => void } object with an `unsubscribe` method to stop listening
   */
  async subscribe(callback) {
    return await __privateGet(this, _iframeMessenger12).createSubscription("proposal/on-change", callback);
  }
};
_iframeMessenger12 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/queued-pub-sub.js
var _eventTarget, _queued, _subscribers, _dispatch, dispatch_fn;
var QueuedPubSub = class {
  constructor() {
    __privateAdd(this, _dispatch);
    __privateAdd(this, _eventTarget, new EventTarget());
    __privateAdd(this, _queued, []);
    __privateAdd(this, _subscribers, /* @__PURE__ */ new Set());
  }
  subscribe(handler) {
    const internalHandler = (_event) => {
      const event = _event;
      handler(event.detail);
    };
    const subscriber = Symbol();
    __privateGet(this, _subscribers).add(subscriber);
    __privateGet(this, _eventTarget).addEventListener("event", internalHandler);
    if (__privateGet(this, _queued).length > 0) {
      const queued = __privateGet(this, _queued);
      __privateSet(this, _queued, []);
      for (const data of queued) {
        __privateMethod(this, _dispatch, dispatch_fn).call(this, data);
      }
    }
    return () => {
      __privateGet(this, _subscribers).delete(subscriber);
      __privateGet(this, _eventTarget).removeEventListener("event", internalHandler);
    };
  }
  publish(data) {
    if (__privateGet(this, _subscribers).size === 0) {
      __privateGet(this, _queued).push(data);
    } else {
      __privateMethod(this, _dispatch, dispatch_fn).call(this, data);
    }
  }
};
_eventTarget = new WeakMap();
_queued = new WeakMap();
_subscribers = new WeakMap();
_dispatch = new WeakSet();
dispatch_fn = function(data) {
  __privateGet(this, _eventTarget).dispatchEvent(new CustomEvent("event", {
    detail: data
  }));
};

// node_modules/forma-embedded-view-sdk/dist/internal/scene/camera.js
function loadImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve(img);
    };
    img.onerror = () => {
      reject(new Error("Failed to load image"));
    };
    img.src = url;
  });
}
async function canvasFromDataUrl(url, width, height) {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    throw new Error("Failed to get 2d context from canvas");
  }
  const imageElement = await loadImage(url);
  ctx.drawImage(imageElement, 0, 0);
  return canvas;
}
var _iframeMessenger13;
var CameraApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger13, void 0);
    __privateSet(this, _iframeMessenger13, iframeMessenger);
  }
  /**
   * Move camera view to a new position.
   *
   * @example
   * // Move camera to view down on the center of the proposal from directly
   * // above, spending 1 second on the transition.
   * await Forma.camera.move({
   *   position: { x: 0, y: 0, z: 100 },
   *   target: { x: 0, y: 0, z: 0 },
   *   transitionTimeMs: 1000,
   * })
   */
  async move(request) {
    await __privateGet(this, _iframeMessenger13).sendRequest("scene/camera/move", request);
  }
  /**
   * Toggle between perspective and orthographic camera.
   *
   * @example
   * await Forma.camera.switchPerspective()
   */
  async switchPerspective() {
    await __privateGet(this, _iframeMessenger13).sendRequest("scene/camera/switch-perspective");
  }
  /**
   * Capture a screenshot of the current camera view as a canvas.
   *
   * @returns Canvas with the captured screenshot.
   *
   * @example
   * // Capture a 100x100 pixel screenshot of the current camera view.
   * const canvas = await Forma.camera.capture({ width: 100, height: 100 })
   */
  async capture(request) {
    return await canvasFromDataUrl(await __privateGet(this, _iframeMessenger13).sendRequest("scene/camera/capture", request), request.width, request.height);
  }
  /**
   * Fetch the current camera state in the designmode scene.
   *
   * @returns Current camera state.
   *
   * @example
   * const currentCameraState = await Forma.camera.getCurrent()
   */
  async getCurrent() {
    return await __privateGet(this, _iframeMessenger13).sendRequest("scene/camera/get-current");
  }
};
_iframeMessenger13 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/scene/design-tool.js
var _iframeMessenger14;
var DesignToolApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger14, void 0);
    __privateSet(this, _iframeMessenger14, iframeMessenger);
  }
  /**
   * Activate tool for creating a point by clicking in the 3D scene.
   *
   * Does not return until the user has selected a point or cancelled the operation (by clicking ESC).
   *
   * @returns The selected point, or `undefined` if the user cancelled the operation.
   *
   * @example
   * const point = await Forma.designTool.getPoint();
   */
  async getPoint() {
    return await __privateGet(this, _iframeMessenger14).sendRequest("design-tool/get-point");
  }
  /**
   * Activate tools for creating a polygon.
   *
   * There are several available tools for creating polygons:
   * 1. "free-form": Click repeatedly in the 3D scene to create a polygon with any number of vertices.
   * 2. "rectangle": Click two points to define the first side of a rectangle, and then a third point along a 90 degree angle to define the second side.
   * 3. "circle": Click a centre and then a point on the circumference to create a circle.
   * 4. "pick": Select an existing shape in the 3D scene and use it as the basis for a new polygon.
   *
   * Does not return until the user has created a polygon or cancelled the operation (by clicking ESC).
   *
   * @returns The created polygon, or `undefined` if the user cancelled the operation.
   *
   * @example
   * const polygon = await Forma.designTool.getPolygon();
   */
  async getPolygon() {
    return await __privateGet(this, _iframeMessenger14).sendRequest("design-tool/get-polygon");
  }
  /**
   * Activate tool for creating an extruded polygon.
   *
   * See {@link getPolygon} for available tools for creating polygons.
   * Once a polygon has been created, choose the height of the extrusion by clicking a final time.
   *
   * Does not return until the user has created an extruded polygon or cancelled the operation (by clicking ESC).
   *
   * @returns The created extruded polygon, or `undefined` if the user cancelled the operation.
   *
   * @example
   * const extrudedPolygon = await Forma.designTool.getExtrudedPolygon();
   */
  async getExtrudedPolygon() {
    return await __privateGet(this, _iframeMessenger14).sendRequest("design-tool/get-extruded-polygon");
  }
  /**
   * Activate tool for creating a line.
   *
   * Click repeatedly in the 3D scene to create a line with any number of vertices.
   *
   * Does not return until the user has created a line or cancelled the operation (by clicking ESC).
   *
   * @returns The created Line, or `undefined` if the user cancelled the operation.
   *
   * @example
   * const line = await Forma.designTool.getLine();
   */
  async getLine() {
    return await __privateGet(this, _iframeMessenger14).sendRequest("design-tool/get-line");
  }
  /**
   * Subscribe to the 'start' event for edits with the drawing tools.
   *
   * @example
   * const { unsubscribe } = await Forma.designTool.onEditStart(() => {
   *  console.log('start event')
   * });
   *
   * @param callback event handler to be called when editing starts
   * @returns { unsubscribe: () => void } object with an `unsubscribe` method to stop listening
   */
  async onEditStart(callback) {
    return __privateGet(this, _iframeMessenger14).createSubscription("scene/design-events/on-edit-start", callback);
  }
  /**
   * Subscribe to the 'end' event for edits with the drawing tools.
   *
   * @example
   * const { unsubscribe } = await Forma.designTool.onEditEnd(() => {
   *  console.log('end event')
   * });
   *
   * @param callback event handler to be called when editing ends
   * @returns { unsubscribe: () => void } object with an `unsubscribe` method to stop listening
   */
  async onEditEnd(callback) {
    return __privateGet(this, _iframeMessenger14).createSubscription("scene/design-events/on-edit-end", callback);
  }
};
_iframeMessenger14 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/scene/renderGlb.js
var _iframeMessenger15;
var RenderGlbApi = class {
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger15, void 0);
    __privateSet(this, _iframeMessenger15, iframeMessenger);
  }
  /**
   * Add a GLB to the scene.
   *
   * @returns Unique identifier of the GLB object in the scene.
   *
   * @example
   * const {id} = await Forma.render.glb.add({ glb }),
   */
  async add(request) {
    return await __privateGet(this, _iframeMessenger15).sendRequest("scene/render/glb/add", request);
  }
  /**
   * Upsert an mesh in the scene. If the mesh does not exist, it will be added.
   *
   * This method can also be used as an upsert.
   *
   * @example
   * await Forma.render.glb.update({ id: "myPreviouslyAddedGlbId", glb })
   */
  async update(request) {
    await __privateGet(this, _iframeMessenger15).sendRequest("scene/render/glb/update", request);
  }
  /**
   * Remove an existing GLB from the scene.
   *
   * @example
   * await Forma.render.glb.remove({ id: "myPreviouslyAddedGlbId" })
   */
  async remove(request) {
    await __privateGet(this, _iframeMessenger15).sendRequest("scene/render/glb/remove", request);
  }
  /**
   * Remove all GLBs added by this API from the scene.
   *
   * Called automatically when the extension is unloaded
   *
   * @example
   * await Forma.render.glb.cleanup()
   */
  async cleanup() {
    await __privateGet(this, _iframeMessenger15).sendRequest("scene/render/glb/cleanup");
  }
};
_iframeMessenger15 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/scene/render.js
var _iframeMessenger16;
var RenderApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger16, void 0);
    __publicField(this, "glb");
    __privateSet(this, _iframeMessenger16, iframeMessenger);
    this.glb = new RenderGlbApi(iframeMessenger);
  }
  /**
   * Add a mesh to the scene.
   *
   * @returns Unique identifier of the mesh object in the scene.
   *
   * @example
   * const {id} = await Forma.render.addMesh({ geometryData }),
   */
  async addMesh(request) {
    return await __privateGet(this, _iframeMessenger16).sendRequest("scene/render/add-mesh", request);
  }
  /**
   * Upsert an mesh in the scene. If the mesh does not exist, it will be added.
   *
   * @example
   * await Forma.render.updateMesh({ id: "myPreviouslyAddedGlbId", geometryData })
   */
  async updateMesh(request) {
    await __privateGet(this, _iframeMessenger16).sendRequest("scene/render/update-mesh", request);
  }
  /**
   * Remove an existing mesh from the scene.
   *
   * @example
   * await Forma.render.remove({ id: "myPreviouslyAddedMeshId" })
   */
  async remove(request) {
    await __privateGet(this, _iframeMessenger16).sendRequest("scene/render/remove", request);
  }
  /**
   * Remove all meshes added by this API from the scene.
   *
   * Called automatically when the extension is unloaded.
   *
   * @example
   * await Forma.render.cleanup()
   */
  async cleanup() {
    await __privateGet(this, _iframeMessenger16).sendRequest("scene/render/cleanup");
  }
};
_iframeMessenger16 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/scene/sun.js
var _iframeMessenger17;
var SunApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger17, void 0);
    __privateSet(this, _iframeMessenger17, iframeMessenger);
  }
  /**
     * Fetch the `Date` corresponding to the current position of the sun in the scene.
     *
     * @remarks
     * Since `Date` objects in JavaScript are based on the instance where the script is run,
     * it is important to capture the discrepancy between the machine local time and the time
     * at the project location. We recommend using a library such as
     * [Luxon](https://moment.github.io/luxon/) to handle this
     * -- their website has a lot of good documentation on the intricacies of time zones.
     *
     * @returns Date for the current sun position.
     *
     * @example
     * import { DateTime } from "luxon";
  
     * const projectTimezone = await Forma.project.getTimezone();
     * const projectDate = await Forma.sun.getDate()
     * const currentDate = DateTime.fromJSDate(currentDate, { zone: projectTimezone });
     */
  async getDate() {
    return await __privateGet(this, _iframeMessenger17).sendRequest("scene/sun/get-date");
  }
  /**
   * Set the position of the sun in the scene.
   *
   * @remarks
   * Since `Date` objects in JavaScript are based on the instance where the script is run,
   * it is important to capture the discrepancy between the machine local time and the time
   * at the project location. We recommend using a library such as
   * [Luxon](https://moment.github.io/luxon/) to handle this
   * -- their website has a lot of good documentation on the intricacies of time zones.
   *
   * @example
   * import { DateTime } from "luxon";
   *
   * const projectTimezone = await Forma.project.getTimezone();
   * const wantedDate = DateTime.fromISO("2023-07-01T13:37:00", { zone: projectTimezone });
   * await Forma.sun.setDate({ date: wantedDate.toJSDate() });
   */
  async setDate(request) {
    await __privateGet(this, _iframeMessenger17).sendRequest("scene/sun/set-date", request);
  }
};
_iframeMessenger17 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/scene/terrain.js
var _iframeMessenger18;
var TerrainApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger18, void 0);
    __publicField(this, "groundTexture");
    __privateSet(this, _iframeMessenger18, iframeMessenger);
    this.groundTexture = new GroundTextureApi(iframeMessenger);
  }
  /**
   * Fetch the bounding box for the terrain.
   *
   * @returns Axis-aligned bounding box for the terrain.
   * More specifically, the minimum and maximum (x,y,z) values, in the local coordinate system.
   */
  async getBbox() {
    return await __privateGet(this, _iframeMessenger18).sendRequest("scene/terrain/bbox/get");
  }
  /**
   * Retrieves the elevation of the terrain (in meters above sea level) at a specific point within the scene.
   *
   * If the coordinates are outside the terrain mesh, it returns the minimum elevation in the terrain.
   */
  async getElevationAt(request) {
    return await __privateGet(this, _iframeMessenger18).sendRequest("scene/terrain/get-elevation-at", request);
  }
};
_iframeMessenger18 = new WeakMap();
var _iframeMessenger19;
var GroundTextureApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger19, void 0);
    __privateSet(this, _iframeMessenger19, iframeMessenger);
  }
  /**
   * Add a ground texture to the terrain.
   *
   * @example
   * // Create canvas
   * const canvas = document.createElement("canvas");
   * canvas.width = 100;
   * canvas.height = 100;
   *
   * // Fill canvas with blue color
   * const ctx = canvas.getContext("2d");
   * if (ctx) {
   *    ctx.fillStyle = "blue";
   *    ctx.fillRect(0, 0, 100, 100);
   *
   *    // Add canvas as ground texture to position (0, 0) in the local coordinate system.
   *    // The texture will cover a 100x100 meter square area on the terrain,
   *    // with lower left corner in (x: -50, y: -50) and upper right corner in (x: 50, y: 50).
   *    await Forma.terrain.groundTexture.add({
   *        name: "myGroundTexture",
   *        canvas,
   *        position: { x: 0, y: 0, z: 1 },
   *        scale: { x: 1, y: 1 },
   *      });
   * }
   */
  async add(request) {
    const canvasUrl = request.canvas.toDataURL();
    await __privateGet(this, _iframeMessenger19).sendRequest("scene/terrain/ground-texture/add", {
      name: request.name,
      canvasUrl,
      position: request.position,
      scale: request.scale
    });
  }
  /**
   * Update the texture data for an existing ground texture object.
   *
   * @example
   * // Create a new canvas filled with red and update the ground texture with this new texture
   * const newCanvas = document.createElement("newCanvas");
   * newCanvas.width = 100;
   * newCanvas.height = 100;
   * const ctx = newCanvas.getContext("2d");
   * if (ctx) {
   *    ctx.fillStyle = "red";
   *    ctx.fillRect(0, 0, 100, 100);
   *    await Forma.terrain.groundTexture.updateTextureData({
   *        name: "myGroundTexture",
   *        canvas: newCanvas,
   *    });
   * }
   */
  async updateTextureData(request) {
    const canvasUrl = request.canvas.toDataURL();
    await __privateGet(this, _iframeMessenger19).sendRequest("scene/terrain/ground-texture/update-texture-data", { name: request.name, canvasUrl });
  }
  /**
   * Update the placement of an existing ground texture object.
   *
   * @example
   * // Move "myGroundTexture" to (100, 100) in the local coordinate system.
   * await Forma.terrain.groundTexture.updatePosition({
   *   name: "myGroundTexture",
   *   position: { x: 100, y: 100, z: 1 }
   * })
   */
  async updatePosition(request) {
    await __privateGet(this, _iframeMessenger19).sendRequest("scene/terrain/ground-texture/update-position", request);
  }
  /**
   * Remove an existing ground texture object.
   *
   * @example
   * // Remove "myGroundTexture".
   * await Forma.terrain.groundTexture.remove({ name: "myGroundTexture" })
   */
  async remove(request) {
    await __privateGet(this, _iframeMessenger19).sendRequest("scene/terrain/ground-texture/remove", request);
  }
};
_iframeMessenger19 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/selection.js
var _iframeMessenger20;
var SelectionApi = class {
  /** @hidden */
  constructor(iframeMessenger) {
    __privateAdd(this, _iframeMessenger20, void 0);
    __privateSet(this, _iframeMessenger20, iframeMessenger);
  }
  /**
   * Get selected elements.
   *
   * @returns List of paths to elements currently selected in the scene.
   *
   * @example
   * // Fetch all paths to selected elements in the current proposal.
   * // Count how many of them are buildings.
   * const selectedPaths = await Forma.selection.getSelection()
   * const buildingPaths = await Forma.geometry.getPathsByCategory({ category: "buildings" })
   * const selectedBuildingPaths = selectedPaths.filter(path => buildingPaths.includes(path))
   * const numberOfSelectedBuildings = selectedBuildingPaths.length
   */
  async getSelection() {
    return await __privateGet(this, _iframeMessenger20).sendRequest("scene/selection/get");
  }
  /**
   * Subscribe to selection changes.
   *
   * @example
   * const { unsubscribe } = await Forma.selection.subscribe(({ paths }) => {
   *  console.log(paths)
   * });
   *
   * @param callback event handler for each selection change
   * @returns { unsubscribe: () => void } object with an `unsubscribe` method to stop listening
   */
  async subscribe(callback) {
    return await __privateGet(this, _iframeMessenger20).createSubscription("scene/selection/on-change", callback);
  }
};
_iframeMessenger20 = new WeakMap();

// node_modules/forma-embedded-view-sdk/dist/internal/version.js
var version = "0.44.0";

// node_modules/forma-embedded-view-sdk/dist/internal/embedded-view.js
var defaultAllowedOrigins = [
  // EU Prod
  "https://app.autodeskforma.com",
  /^https:\/\/local\.autodeskforma\.com:/,
  // US Prod
  "https://app.autodeskforma.eu",
  /^https:\/\/local\.autodeskforma\.eu:/,
  // EU Chaos
  "https://app.spacemakerai.eu",
  /^https:\/\/local\.spacemakerai\.eu:/
];
var _iframeMessenger21, _customRequestHandlers, _customEventHandlers, _customSubscribeHandlers, _iframeResizer, _messagePorts;
var _EmbeddedViewSdk = class _EmbeddedViewSdk {
  constructor(config) {
    __publicField(this, "config");
    __publicField(this, "source", window.parent);
    __privateAdd(this, _iframeMessenger21, void 0);
    __publicField(this, "origin");
    __publicField(this, "analysis");
    __publicField(this, "extensions");
    __publicField(this, "elements");
    __publicField(this, "generators");
    __publicField(this, "geometry");
    __publicField(this, "integrateElements");
    __publicField(this, "library");
    __publicField(this, "project");
    __publicField(this, "proposal");
    __publicField(this, "camera");
    __publicField(this, "sun");
    __publicField(this, "terrain");
    __publicField(this, "render");
    __publicField(this, "selection");
    __publicField(this, "areaMetrics");
    __publicField(this, "predictiveAnalysis");
    __publicField(this, "designTool");
    __privateAdd(this, _customRequestHandlers, /* @__PURE__ */ new Map());
    __privateAdd(this, _customEventHandlers, /* @__PURE__ */ new Map());
    __privateAdd(this, _customSubscribeHandlers, /* @__PURE__ */ new Map());
    __privateAdd(this, _iframeResizer, new ResizeObserver((entries) => {
      const htmlEntry = entries.find((entry) => entry.target === document.documentElement);
      if (htmlEntry) {
        __privateGet(this, _iframeMessenger21).sendRequest("resizeIframeHeight", {
          height: htmlEntry.contentRect.height
        }).catch((err) => {
          console.log("failed to resize iframe", err);
        });
      }
    }));
    __privateAdd(this, _messagePorts, new QueuedPubSub());
    this.config = config;
    this.origin = (config == null ? void 0 : config.origin) ?? _EmbeddedViewSdk.getHostOrigin();
    const allowedOrigins = (config == null ? void 0 : config.allowedOrigins) ?? defaultAllowedOrigins;
    if (!allowedOrigins.some((allowedOrigin) => typeof allowedOrigin === "string" ? allowedOrigin === this.origin : allowedOrigin.test(this.origin))) {
      throw new Error(`Unsupported origin: ${this.origin}`);
    }
    __privateSet(this, _iframeMessenger21, new IframeMessenger({
      sourceOrigin: this.origin,
      source: this.source,
      requestResolver: (action) => __privateGet(this, _customRequestHandlers).get(action),
      eventResolver: (action) => __privateGet(this, _customEventHandlers).get(action),
      subscribeResolver: (name) => __privateGet(this, _customSubscribeHandlers).get(name),
      debug: config == null ? void 0 : config.debug
    }));
    __privateGet(this, _iframeMessenger21).connect();
    void __privateGet(this, _iframeMessenger21).sendEvent("sdk-version", {
      version
    });
    window.addEventListener("beforeunload", () => {
      __privateGet(this, _iframeMessenger21).disconnect();
    });
    window.addEventListener("focus", () => {
      void __privateGet(this, _iframeMessenger21).sendEvent("window-focused");
    });
    this.analysis = new AnalysisApi(__privateGet(this, _iframeMessenger21));
    this.extensions = new ExtensionsApi(__privateGet(this, _iframeMessenger21));
    this.elements = new ElementsApi(__privateGet(this, _iframeMessenger21));
    this.generators = new GeneratorsApi(__privateGet(this, _iframeMessenger21));
    this.geometry = new GeometryApi(__privateGet(this, _iframeMessenger21));
    this.integrateElements = new IntegrateApi(__privateGet(this, _iframeMessenger21));
    this.library = new LibraryApi(__privateGet(this, _iframeMessenger21));
    this.project = new ProjectApi(__privateGet(this, _iframeMessenger21));
    this.proposal = new ProposalApi(__privateGet(this, _iframeMessenger21));
    this.camera = new CameraApi(__privateGet(this, _iframeMessenger21));
    this.sun = new SunApi(__privateGet(this, _iframeMessenger21));
    this.terrain = new TerrainApi(__privateGet(this, _iframeMessenger21));
    this.render = new RenderApi(__privateGet(this, _iframeMessenger21));
    this.selection = new SelectionApi(__privateGet(this, _iframeMessenger21));
    this.areaMetrics = new AreaMetricsApi(__privateGet(this, _iframeMessenger21));
    this.predictiveAnalysis = new PredictiveAnalysisApi(__privateGet(this, _iframeMessenger21));
    this.designTool = new DesignToolApi(__privateGet(this, _iframeMessenger21));
    __privateGet(this, _iframeResizer).observe(document.documentElement);
    __privateGet(this, _customRequestHandlers).set("receive-message-port", (payload) => {
      __privateGet(this, _messagePorts).publish(payload);
    });
  }
  async ping() {
    return await __privateGet(this, _iframeMessenger21).sendRequest("ping");
  }
  /**
   * @hidden
   * @internal
   */
  getIframeMessenger() {
    return __privateGet(this, _iframeMessenger21);
  }
  getProjectId() {
    const projectId = new URLSearchParams(window.location.search).get("projectId");
    if (!projectId) {
      throw new Error("Missing query parameter: projectId");
    }
    return projectId;
  }
  getExtensionId() {
    const extensionId = new URLSearchParams(window.location.search).get("extensionId");
    if (!extensionId) {
      throw new Error("Missing query parameter: extensionId");
    }
    return extensionId;
  }
  /**
   * Check for access to perform edit operations in the current project.
   *
   * @example
   * ```js
   * const canEdit = await Forma.getCanEdit()
   * if (canEdit) {
   *  await Forma.proposal.addElement({ urn })
   * } else {
   *   console.log("User need to have collaborator or admin role to add elements")
   * }
   * ```
   */
  async getCanEdit() {
    return await __privateGet(this, _iframeMessenger21).sendRequest("access/can-edit");
  }
  /**
   * Retrieve the embedded view ID used to identify this embedded view.
   *
   * You can set a custom embedded view ID when dynamically opening
   * an embedded view inside a floating panel.
   */
  getEmbeddedViewId() {
    const embeddedViewId = new URLSearchParams(window.location.search).get("embeddedViewId");
    if (!embeddedViewId) {
      throw new Error("Missing query parameter: embeddedViewId");
    }
    return embeddedViewId;
  }
  static getHostOrigin() {
    const origin = new URLSearchParams(window.location.search).get("origin");
    if (!origin) {
      throw new Error("Missing query parameter: origin");
    }
    return origin;
  }
  /**
   * @hidden
   * @internal
   */
  setRequestHandler(name, handler) {
    __privateGet(this, _customRequestHandlers).set(name, handler);
  }
  /**
   * @hidden
   * @internal
   */
  setEventHandler(name, handler) {
    __privateGet(this, _customEventHandlers).set(name, handler);
  }
  /**
   * @hidden
   * @internal
   */
  setSubscribeHandler(name, handler) {
    __privateGet(this, _customSubscribeHandlers).set(name, handler);
  }
  /**
   * @hidden
   * @internal
   */
  sendRequest(action, payload, transfer) {
    return __privateGet(this, _iframeMessenger21).sendRequest(action, payload, transfer);
  }
  /**
   * @hidden
   * @internal
   */
  sendEvent(action, payload, transfer) {
    return __privateGet(this, _iframeMessenger21).sendEvent(action, payload, transfer);
  }
  /**
   * @hidden
   * @internal
   */
  createSubscription(name, handler, options) {
    return __privateGet(this, _iframeMessenger21).createSubscription(name, handler, options);
  }
  /**
   * Open another embedded view in a floating panel.
   *
   * The embedded view will be owned by the current embedded view,
   * and automatically closed when the current embedded view is closed.
   *
   * To wait for the embedded view to be ready or being closed, listen to
   * the relevant events via {@link onEmbeddedViewStateChange}
   * before invoking this method. Methods such as {@link createMessagePort}
   * will automatically wait for the embedded view to be ready.
   *
   * If the URL is invalid or the embedded view cannot be initialized,
   * the state of the embedded view will remain open and not connected,
   * until the user closes the panel which triggers the closed state.
   *
   * @experimental
   */
  async openFloatingPanel(options) {
    await __privateGet(this, _iframeMessenger21).sendRequest("open-floating-panel", options);
  }
  /**
   * Close an embedded view belonging to this extension.
   *
   * Currently only floating panels can be closed.
   *
   * If the embedded view is not open this will still resolve successfully.
   *
   * @experimental
   */
  async closeEmbeddedView(options) {
    await __privateGet(this, _iframeMessenger21).sendRequest("close-embedded-view", options);
  }
  /**
   * Listen to when the state of an embedded view belonging to the current
   * extension changes.
   *
   * @experimental
   */
  async onEmbeddedViewStateChange(handler) {
    return __privateGet(this, _iframeMessenger21).createSubscription("on-embedded-view-state-change", handler);
  }
  /**
   * Create a MessagePort that can be used to communicate directly with
   * another embedded view belonging to the current extension.
   *
   * The other embedded view must have called the {@link onMessagePort} method
   * during initialization for this to succeeed.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API
   * @experimental
   */
  async createMessagePort(options) {
    const channel = new MessageChannel();
    await __privateGet(this, _iframeMessenger21).sendRequest("create-message-port", {
      embeddedViewId: options.embeddedViewId,
      portName: options.portName,
      port: channel.port2
    }, [channel.port2]);
    return channel.port1;
  }
  /**
   * Receive a MessagePort initiated from {@link createMessagePort}.
   *
   * The first time this is called, the handler will receive any
   * queued message ports.
   *
   * @returns A function that can be used to unsubscribe.
   *
   * @experimental
   */
  onMessagePort(handler) {
    return __privateGet(this, _messagePorts).subscribe(handler);
  }
};
_iframeMessenger21 = new WeakMap();
_customRequestHandlers = new WeakMap();
_customEventHandlers = new WeakMap();
_customSubscribeHandlers = new WeakMap();
_iframeResizer = new WeakMap();
_messagePorts = new WeakMap();
var EmbeddedViewSdk = _EmbeddedViewSdk;

// node_modules/forma-embedded-view-sdk/dist/auto.js
var Forma = new EmbeddedViewSdk();
export {
  Forma
};
//# sourceMappingURL=forma-embedded-view-sdk_auto.js.map
